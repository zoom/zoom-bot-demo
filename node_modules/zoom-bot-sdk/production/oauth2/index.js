"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../utils/index");

var _index2 = _interopRequireDefault(_index);

var _oauth = require("../plugins/oauth2");

var _oauth2 = _interopRequireDefault(_oauth);

var _refreshToken = require("../plugins/refreshToken");

var _refreshToken2 = _interopRequireDefault(_refreshToken);

var _clientToken = require("../plugins/clientToken");

var _clientToken2 = _interopRequireDefault(_clientToken);

var _add_seconds = require("date-fns/add_seconds");

var _add_seconds2 = _interopRequireDefault(_add_seconds);

var _is_after = require("date-fns/is_after");

var _is_after2 = _interopRequireDefault(_is_after);

var _error = require("../services/error");

var _error2 = _interopRequireDefault(_error);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// import  from 'fs';
class UserToken {
  constructor(connect) {
    // let { refresh_token, code } = opt;
    // this.tokens = { refresh_token };
    // this.code = code;
    this.connect = connect;
    this.clientTokens = {};
    this.tokens = {};
    this.expire_start = null;
    this.expire_end = null;
    this.expire_client_start = null;
    this.expire_client_end = null;
  }

  requestTokensByRefresh(refreshToken) {
    /*  
      (refreshToken:string):Promise|void
      */
    if (!refreshToken) {
      let tokens = this.getTokens();

      if (typeof tokens === 'object') {
        refreshToken = tokens.refresh_token;
      }
    }

    let {
      connect
    } = this;

    if (!connect || !refreshToken) {
      return;
    }

    let {
      appKey,
      appSecret
    } = connect;
    return new Promise((resolve, reject) => {
      (0, _refreshToken2.default)(appKey, appSecret, refreshToken).then(tokens => {
        let out = this.setTokens(tokens);
        connect.trigger('tokens', out);
        resolve(out);
      }).catch(err => {
        connect.trigger('error', _error2.default.token(err));
        reject(err);
      });
    });
  }

  requestTokens(code) {
    let {
      connect
    } = this;

    if (!connect || !code) {
      return;
    }

    let {
      appKey,
      appSecret,
      redirect_uri
    } = connect;
    return new Promise((resolve, reject) => {
      (0, _oauth2.default)(appKey, appSecret, redirect_uri, code).then(tokens => {
        let out = this.setTokens(tokens);
        connect.trigger('tokens', out);
        resolve(out);
      }).catch(err => {
        connect.trigger('error', _error2.default.token(err));
        reject(err);
      });
    });
  }

  requestClientTokens() {
    let {
      connect
    } = this;

    if (!connect) {
      return;
    } //unbind connect


    let {
      appKey,
      appSecret
    } = connect;
    return new Promise((resolve, reject) => {
      (0, _clientToken2.default)(appKey, appSecret).then(tokens => {
        let out = this.clientTokens = Object.assign(this.clientTokens, tokens);
        connect.trigger('clientTokens', out);
        resolve(out);
      }).catch(err => {
        connect.trigger('error', _error2.default.clientToken(err));
        reject(err);
      });
    });
  }

  expiredClient() {
    let date = new Date();

    if (this.expire_client_end) {
      return (0, _is_after2.default)(date, this.expire_client_end);
    } else {
      return false; //if not expire_end, also return false
    }
  }

  expired() {
    let date = new Date();

    if (this.expire_end) {
      return (0, _is_after2.default)(date, this.expire_end);
    } else {
      return false; //if not expire_end, also return false
    }
  }

  setClientTokens(clientTokens) {
    // this.clientTokens = Object.assign(this.clientTokens, tokens);
    this.clientTokens = Object.assign(this.clientTokens, clientTokens);
    let {
      expires_in
    } = clientTokens;

    if (expires_in) {
      let da = this.expire_client_start = new Date();
      this.expire_client_end = (0, _add_seconds2.default)(da, Math.floor(expires_in / 2));
    }

    return clientTokens;
  }

  setTokens(tokens) {
    /* 
    Interface Tokens{
      access_token?:string;
      refresh_token?:string;
      expi
    }
    */
    this.tokens = Object.assign(this.tokens, tokens);
    let {
      expires_in
    } = tokens;

    if (expires_in) {
      let da = this.expire_start = new Date();
      this.expire_end = (0, _add_seconds2.default)(da, expires_in);
    }

    return tokens;
  }

  getClientTokens() {
    //not to others
    let clientTokens = this.clientTokens;

    if (clientTokens.access_token) {
      return clientTokens;
    } else {
      return false;
    }
  }

  getTokens() {
    //not to others
    let tokens = this.tokens;

    if (tokens.access_token) {
      return tokens;
    }

    return false;
  }

  clear() {
    this.connect = null;
  }

}

class Oauth2 extends _index2.default.Event {
  constructor(appKey, appSecret, redirect_uri) {
    super();
    this.appKey = appKey;
    this.appSecret = appSecret;
    this.redirect_uri = redirect_uri;
    this.store = {};
  }

  on(eventType, callback) {
    if (!eventType || typeof callback !== 'function') {
      return;
    }

    if (Oauth2.supportEvents.indexOf(eventType) !== -1) {
      //is supported event;
      super.on(eventType, callback);
    } else {
      _index2.default.debug()(`${eventType} is not supported event`);
    }
  }

  connectByRefresh(refreshToken) {
    /* 
        (refreshToken:string):Promise
    */
    return new Promise((resolve, reject) => {
      let newConnection = new UserToken(this);
      newConnection.requestTokensByRefresh(refreshToken).then(() => {
        resolve(newConnection);
      }).catch(err => {
        reject(err);
      });
    });
  }

  connectByCode(code) {
    return new Promise((resolve, reject) => {
      let newConnection = new UserToken(this);
      newConnection.requestTokens(code).then(() => {
        resolve(newConnection);
      }).catch(err => {
        reject(err);
      });
    });
  }

  connectByTokens(tokens) {
    let newConnection = new UserToken(this);
    newConnection.setTokens(tokens);
    return newConnection;
  }

  connect() {
    /* 
    ():UserToken
    */
    return new UserToken(this);
  }

}

Oauth2.supportEvents = ['tokens', 'clientTokens', 'error'];
exports.default = Oauth2;
module.exports = exports.default;