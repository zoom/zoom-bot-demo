"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _index = require("../utils/index");

var _index2 = _interopRequireDefault(_index);

var _transform = require("../services/transform");

var _transform2 = _interopRequireDefault(_transform);

var _ClientApp = require("./ClientApp");

var _ClientApp2 = _interopRequireDefault(_ClientApp);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

let createInfo = {
  help(commandStore, name) {
    if (!Array.isArray(commandStore)) {
      return false;
    }

    let msg = [];

    if (commandStore.length === 0) {
      msg.push({
        type: 'message',
        text: 'No Command Now'
      });
    } else {
      commandStore.forEach(obj => {
        let {
          command,
          description,
          hint
        } = obj;
        let commandTitle = command;

        if (hint) {
          commandTitle = `${commandTitle} ${hint}`;
        }

        let commandInfo = [{
          type: 'message',
          text: commandTitle,
          style: {
            bold: true
          }
        }];
        let valueInfo = [{
          type: 'message',
          text: description
        }];
        msg = msg.concat(commandInfo);
        msg = msg.concat(valueInfo);
      });
    }

    let title = `Hi this is bot commands`;

    if (name) {
      title = `Hi this is ${name} bot commands`;
    }

    let header = {
      text: title
    };
    return {
      body: msg,
      header
    };
  }

};

class Client extends _index2.default.Event {
  constructor(appKey, verification_token, robot_jid, name = '') {
    super();
    this.appKey = appKey;
    this.robot_jid = robot_jid;
    this.verification_token = verification_token;
    this.commandStore = []; // this.commandNameStore=[];

    this.focusApp = null;
    this.name = name;
    this.config = {
      help: true,
      errorHelp: false
    };
    this.v = '';
  }

  configurate(opt) {
    if (typeof opt !== 'object') {
      return this;
    }

    this.config = Object.assign(this.config, opt);
    return this;
  }

  checkCommands(command) {
    if (typeof command !== 'string') {
      return false;
    }

    let {
      commandStore
    } = this;

    for (let obj of commandStore) {
      if (command === obj.command) {
        return true;
      }
    }

    return false;
  }

  defaultAuth(connection) {
    if (connection) {
      let {
        robot_jid
      } = this;
      this.focusApp = new _ClientApp2.default(robot_jid, connection);
    }

    return this;
  }

  create(opt) {
    let {
      auth
    } = opt;
    let {
      robot_jid
    } = this;
    let newApp = new _ClientApp2.default(robot_jid, auth);

    if (this.focusApp === null) {
      this.focusApp = newApp;
    }

    return newApp;
  }

  command(opts) {
    //abandon method
    if (Array.isArray(opts)) {
      opts.forEach(obj => {
        this._commandObj(obj);
      });
    } else if (typeof opts === 'object') {
      this._commandObj(opts);
    }

    return this;
  }

  _commandObj(obj) {
    //aband
    if (typeof obj === 'object') {
      //['command','description'] hint?
      if (_index2.default.hasAllAttrs(obj, ['command', 'description'])) {
        this.commandStore.push(obj);
      }
    }
  }

  _commandsObj(obj) {
    if (typeof obj === 'object') {
      //['command','description'] hint?
      if (_index2.default.hasAllAttrs(obj, ['command', 'description'])) {
        this.commandStore.push(obj);
      }
    }
  }

  commands(opts) {
    if (Array.isArray(opts)) {
      opts.forEach(obj => {
        this._commandsObj(obj);
      });
    } else if (typeof opts === 'object') {
      this._commandsObj(opts);
    }

    return this;
  }

  version(v) {
    this.v = v;
    return this;
  }

  parse({
    body,
    headers
  }) {
    let out = this.route({
      body,
      headers
    });
    let {
      status,
      result
    } = out;

    if (status === false) {
      return out;
    } else if (status === true) {
      let {
        cmdOption,
        type,
        message,
        value,
        data
      } = result;
      return {
        status,
        data: {
          command: cmdOption.command,
          hint: cmdOption.hint,
          message,
          type,
          payload: data,
          event: value
        }
      };
    }
  }

  route({
    body,
    headers
  }) {
    let {
      appKey,
      verification_token
    } = this;

    let out = _transform2.default.get({
      body,
      headers,
      store: this.store,
      appKey,
      verification_token
    });

    return out;
  }

  triggerHelp(accountId, toJid) {
    this._triggerHelp({
      accountId,
      toJid
    });
  }

  _triggerHelp(data) {
    let {
      accountId: account_id,
      toJid: to_jid
    } = data;
    let {
      focusApp,
      commandStore,
      name
    } = this;
    let helpInfo = createInfo.help(commandStore, name);
    return new Promise((resolve, reject) => {
      if (helpInfo === false) {
        resolve();
      } //not trigger error in this


      focusApp.sendMessage({
        to_jid,
        account_id,
        body: helpInfo.body,
        header: helpInfo.header
      }).then(da => {
        resolve(da);
      }).catch(e => {
        reject(e);
      });
    });
  }

  async handleCallback(result, allCallback) {
    //run the help split,and normal command split,and parse one to one and group,and commandName
    let {
      type,
      innerCmd,
      value,
      data,
      cmdOption = {},
      message
    } = result;
    let {
      focusApp,
      config
    } = this;

    if (config.help === true && value === 'notification' && innerCmd === 'help' && focusApp !== null) {
      try {
        this._triggerHelp(data);

        allCallback(null);
      } catch (e) {
        allCallback(e);
      }
    } else {
      if (config.errorHelp === true) {
        //auto trigger error help
        let ifCommand = this.checkCommands(cmdOption.command);

        if (ifCommand === false) {
          try {
            this._triggerHelp(data);
          } catch (e) {
            allCallback(e);
          }

          return;
        }
      }

      let sendData = {
        payload: data,
        data: cmdOption.hint,
        type,
        message,
        command: cmdOption.command
      };

      if (typeof allCallback === 'function') {
        allCallback(null, sendData);
      }

      this.trigger(value, {
        data,
        type,
        command: value
      }); //old trigger

      this.trigger('command', {
        data,
        type,
        command: value
      }); //old trigger
      //change data->commands

      this.trigger('commands', sendData);
    }
  }

  handle({
    body,
    headers
  }, allCallback) {
    if (typeof allCallback === 'function') {
      return this.handleCompatibility({
        body,
        headers
      }, allCallback);
    } else {
      return new Promise((resolve, reject) => {
        allCallback = function (error, msg) {
          if (error) {
            reject(error);
          } else {
            resolve(msg);
          }
        };

        if (typeof body !== 'object') {
          reject(`no body and query data`);
          return;
        }

        let routeEntity = this.route({
          body,
          headers
        });

        if (routeEntity.status === false) {
          reject(routeEntity.errorMessage);
        } else {
          this.handleCallback(routeEntity.result, allCallback);
        }
      });
    }
  }

  handleCompatibility({
    body,
    headers
  }, allCallback) {
    if (typeof body !== 'object') {
      //only check body
      if (typeof allCallback === 'function') {
        allCallback(`no body and query data`);
      }

      return this;
    } //get transform message


    let routeEntity = this.route({
      body,
      headers
    });

    if (routeEntity.status === false) {
      if (routeEntity.errorMessage && typeof allCallback === 'function') {
        allCallback(routeEntity.errorMessage);
      }

      return this;
    } //value is which route to route
    //split help and command


    this.handleCallback(routeEntity.result, allCallback);
    return this;
  }

}

exports.default = Client;
module.exports = exports.default;