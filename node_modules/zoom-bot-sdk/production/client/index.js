"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Utils = require("Utils");

var _Utils2 = _interopRequireDefault(_Utils);

var _transform = require("Services/transform");

var _transform2 = _interopRequireDefault(_transform);

var _channelList = require("Plugins/channelList");

var _channelList2 = _interopRequireDefault(_channelList);

var _sendMessage = require("Plugins/sendMessage");

var _sendMessage2 = _interopRequireDefault(_sendMessage);

var _getUser = require("Plugins/getUser");

var _getUser2 = _interopRequireDefault(_getUser);

var _error = require("Services/error");

var _error2 = _interopRequireDefault(_error);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class ClientApp {
  constructor(robot_jid, auth) {
    this.robot_jid = robot_jid;
    this.auth = auth;
  }

  getToken(func, fail) {
    let {
      auth
    } = this;
    let expired = auth.expired();
    let tokens = auth.getTokens();

    if (tokens === false) {
      let msg = `don't get tokens before use action`;

      _error2.default.code({
        type: 'code',
        message: msg
      });

      fail(msg);
      return;
    }

    let {
      refresh_token,
      access_token
    } = tokens;

    if (expired === true) {
      auth.requestTokensByRefresh(refresh_token).then(newTokens => {
        func(newTokens.access_token);
      }).catch(err => {
        fail(err);
      });
    } else {
      func(access_token);
    }
  }

  getClientToken(func, fail) {
    let {
      auth
    } = this;
    let expired = auth.expiredClient();
    let clientTokens = auth.getClientTokens();

    if (clientTokens === false) {
      auth.requestClientTokens().then(newClientTokens => {
        func(newClientTokens.access_token);
      }).catch(err => {
        fail(err);
      });
      return;
    }

    let {
      access_token
    } = clientTokens;

    if (expired === true) {
      auth.requestClientTokens().then(newClientTokens => {
        func(newClientTokens.access_token);
      }).catch(err => {
        fail(err);
      });
    } else {
      func(access_token);
    }
  }

  getUser(email) {
    return new Promise((resolve, reject) => {
      this.getToken(access_token => {
        (0, _getUser2.default)(access_token, email).then(data => {
          resolve(data);
        }).catch(err => {
          reject(err);
        });
      }, err => {
        _error2.default.action({
          type: 'action',
          message: err
        });

        reject(err);
      });
    });
  }

  sendMessage(option) {
    return new Promise((resolve, reject) => {
      this.getClientToken(access_token => {
        let {
          robot_jid
        } = this;
        let {
          body,
          header,
          account_id,
          to_jid
        } = option;
        (0, _sendMessage2.default)(access_token, to_jid, robot_jid, account_id, body, header).then(data => {
          resolve(data);
        }).catch(err => {
          reject(err);
        });
      }, err => {
        _error2.default.action({
          type: 'action',
          message: err
        });

        reject(err);
      });
    }); // return sendMessage(userId,to_jid,body,header)
  }

  channelList(userId) {
    return new Promise((resolve, reject) => {
      this.getToken(access_token => {
        (0, _channelList2.default)(access_token, userId).then(data => {
          resolve(data);
        }).catch(err => {
          reject(err);
        });
      }, err => {
        _error2.default.action({
          type: 'action',
          message: err
        });

        reject(err);
      });
    });
  }

  clear() {
    this.auth = null;
  }

}

class Client extends _Utils2.default.Event {
  constructor(appKey, verification_token, robot_jid, name = '') {
    super();
    this.appKey = appKey;
    this.robot_jid = robot_jid;
    this.verification_token = verification_token;
    this.commandStore = [];
    this.focusApp = null;
    this.name = name;
    this.v = '';
  }

  defaultAuth(connection) {
    if (connection) {
      let {
        robot_jid
      } = this;
      this.focusApp = new ClientApp(robot_jid, connection);
    }

    return this;
  }

  create(opt) {
    //opt reserve
    // if (typeof opt !== 'object') {
    //   utils.debug()(
    //     `create client must input object which include auth or tokens,clientTokens`
    //   );
    //   return;
    // }
    let {
      auth
    } = opt;
    let {
      robot_jid
    } = this;
    let newApp = new ClientApp(robot_jid, auth);

    if (this.focusApp === null) {
      this.focusApp = newApp;
    }

    return newApp;
  }

  command(opts) {
    //abandon method
    if (Array.isArray(opts)) {
      opts.forEach(obj => {
        this._commandObj(obj);
      });
    } else if (typeof opts === 'object') {
      this._commandObj(opts);
    }

    return this;
  }

  _commandObj(obj) {
    //aband
    if (typeof obj === 'object') {
      //['command','description'] hint?
      if (_Utils2.default.hasAllAttrs(obj, ['command', 'description'])) {
        this.commandStore.push(obj);
      }
    }
  }

  _commandsObj(obj) {
    if (typeof obj === 'object') {
      //['command','description'] hint?
      if (_Utils2.default.hasAllAttrs(obj, ['command', 'description'])) {
        this.commandStore.push(obj);
      }
    }
  }

  commands(opts) {
    if (Array.isArray(opts)) {
      opts.forEach(obj => {
        this._commandsObj(obj);
      });
    } else if (typeof opts === 'object') {
      this._commandsObj(opts);
    }

    return this;
  }

  version(v) {
    this.v = v;
    return this;
  }

  route({
    body,
    headers
  }) {
    let {
      appKey,
      verification_token
    } = this;

    let out = _transform2.default.get({
      body,
      headers,
      store: this.store,
      appKey,
      verification_token
    });

    return out;
  }

  async triggerHelp(data, allCallback) {
    let {
      accountId: account_id,
      toJid: to_jid
    } = data;
    let {
      focusApp,
      commandStore,
      name
    } = this;
    let msg = [];

    if (commandStore.length === 0) {
      msg.push({
        type: 'message',
        text: 'No Command Now'
      });
    } else {
      commandStore.forEach(obj => {
        let {
          command,
          hint,
          description
        } = obj;
        let commandTitle = command;

       if (hint) {
          commandTitle = `${commandTitle} ${hint}`;
        }

        let commandInfo = [{
          type: 'message',
          text: commandTitle,
          style: {
            bold: true
          }
        }];

      /*  let hintinfo = [{
          type: 'message',
          text: hint,
          style: {
            bold: false
          }
      }];*/

        let valueInfo = [{
          type: 'message',
          text: description,
        /*  style: {
            italic: true,
          }*/
        }];
        msg = msg.concat(commandInfo);
      //  msg = msg.concat(hintinfo);
        msg = msg.concat(valueInfo);
      });
    }

    let title = `Hi this is bot commands`;

    if (name) {
      title = `Here are the commands for ${name} bot`;
    }

    try {
      //this position
      await focusApp.sendMessage({
        to_jid,
        account_id,
        body: msg,
        header: {
          text: title
        }
      });
    } catch (e) {
      if (typeof allCallback === 'function') {
        allCallback(e);
      }
    }
  }

  handleCallback(result, allCallback) {
    //run the help split,and normal command split,and parse one to one and group,and commandName
    let {
      type,
      innerCmd,
      value,
      data,
      cmdOption = {},
      message
    } = result;
    let {
      focusApp
    } = this;

    if (value === 'notification' && innerCmd === 'help' && focusApp !== null) {
      this.triggerHelp(data, allCallback);
    } else {
      this.trigger(value, {
        data,
        type,
        command: value
      }); //old trigger

      this.trigger('command', {
        data,
        type,
        command: value
      }); //old trigger
      //change data->commands

      this.trigger('commands', {
        payload: data,
        data: cmdOption.hint,
        type,
        message,
        command: cmdOption.command
      });
    }
  }

  handle({
    body,
    headers
  }, allCallback) {
    if (typeof body !== 'object') {
      //only check body
      if (typeof allCallback === 'function') {
        allCallback(`no body and query data`);
      }

      return this;
    }

    let routeEntity = this.route({
      body,
      headers
    });

    if (routeEntity.status === false) {
      if (routeEntity.errorMessage && typeof allCallback === 'function') {
        allCallback(routeEntity.errorMessage);
      }

      return this;
    } //value is which route to route
    //split help and command


    this.handleCallback(routeEntity.result, allCallback); // this.trigger(value, {data});
    // .then(() => {
    //   if (typeof allCallback === 'function') {
    //     allCallback(null);
    //   }
    // })
    // .catch(err => {
    //   if (typeof allCallback === 'function') {
    //     allCallback(err);
    //   }
    // });

    return this;
  }

}

exports.default = Client;
module.exports = exports.default;
