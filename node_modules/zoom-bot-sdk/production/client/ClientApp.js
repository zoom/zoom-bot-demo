"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _channelList = require("../plugins/channelList");

var _channelList2 = _interopRequireDefault(_channelList);

var _sendMessage = require("../plugins/sendMessage");

var _sendMessage2 = _interopRequireDefault(_sendMessage);

var _getUser = require("../plugins/getUser");

var _getUser2 = _interopRequireDefault(_getUser);

var _request = require("../plugins/request");

var _request2 = _interopRequireDefault(_request);

var _error = require("../services/error");

var _error2 = _interopRequireDefault(_error);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class ClientApp {
  constructor(robot_jid, auth) {
    this.robot_jid = robot_jid;
    this.auth = auth;
  }

  getToken(func, fail) {
    let {
      auth
    } = this;
    let expired = auth.expired();
    let tokens = auth.getTokens();

    if (tokens === false) {
      let msg = `don't get tokens before use action`;

      _error2.default.code({
        type: 'code',
        message: msg
      });

      fail(msg);
      return;
    }

    let {
      refresh_token,
      access_token
    } = tokens;

    if (expired === true) {
      auth.requestTokensByRefresh(refresh_token).then(newTokens => {
        func(newTokens.access_token);
      }).catch(err => {
        fail(err);
      });
    } else {
      func(access_token);
    }
  }

  getClientToken(func, fail) {
    let {
      auth
    } = this;
    let expired = auth.expiredClient();
    let clientTokens = auth.getClientTokens();

    if (clientTokens === false) {
      auth.requestClientTokens().then(newClientTokens => {
        func(newClientTokens.access_token);
      }).catch(err => {
        fail(err);
      });
      return;
    }

    let {
      access_token
    } = clientTokens;

    if (expired === true) {
      auth.requestClientTokens().then(newClientTokens => {
        func(newClientTokens.access_token);
      }).catch(err => {
        fail(err);
      });
    } else {
      func(access_token);
    }
  }

  request(opt, type = 'access') {
    if (typeof opt !== 'object') {
      throw new _error2.default.ParamError(`${opt} must be object`); // return;
    }

    return new Promise((resolve, reject) => {
      if (type === 'access') {
        type = 'getToken';
      } else if (type === 'credential') {
        type = 'getClientToken';
      } else {
        reject(`param type must be access or credential`);
        return;
      }

      this[type](access_token => {
        (0, _request2.default)(access_token, opt).then(data => {
          resolve(data);
        }).catch(err => {
          reject(err);
        });
      }, err => {
        _error2.default.action({
          type: 'action',
          message: err
        });

        reject(err);
      });
    });
  }

  getUser(email) {
    return new Promise((resolve, reject) => {
      this.getToken(access_token => {
        (0, _getUser2.default)(access_token, email).then(data => {
          resolve(data);
        }).catch(err => {
          reject(err);
        });
      }, err => {
        _error2.default.action({
          type: 'action',
          message: err
        });

        reject(err);
      });
    });
  }

  sendMessage(option) {
    return new Promise((resolve, reject) => {
      this.getClientToken(access_token => {
        let {
          robot_jid
        } = this;
        let {
          body,
          header,
          account_id,
          to_jid
        } = option;
        (0, _sendMessage2.default)(access_token, to_jid, robot_jid, account_id, body, header).then(data => {
          resolve(data);
        }).catch(err => {
          reject(err);
        });
      }, err => {
        _error2.default.action({
          type: 'action',
          message: err
        });

        reject(err);
      });
    }); // return sendMessage(userId,to_jid,body,header)
  }

  channelList(userId) {
    return new Promise((resolve, reject) => {
      this.getToken(access_token => {
        (0, _channelList2.default)(access_token, userId).then(data => {
          resolve(data);
        }).catch(err => {
          reject(err);
        });
      }, err => {
        _error2.default.action({
          type: 'action',
          message: err
        });

        reject(err);
      });
    });
  }

  clear() {
    this.auth = null;
  }

}

exports.default = ClientApp;
module.exports = exports.default;