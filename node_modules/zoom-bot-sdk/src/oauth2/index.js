import utils from 'Utils';
import oauth2 from 'Plugins/oauth2';
import refreshTokenFunc from 'Plugins/refreshToken';
import clientTokenFunc from 'Plugins/clientToken';
// import  from 'fs';
import addSeconds from 'date-fns/add_seconds';
import isAfter from 'date-fns/is_after';
import error from 'Services/error';

class UserToken {
  constructor(connect) {
    // let { refresh_token, code } = opt;
    // this.tokens = { refresh_token };
    // this.code = code;
    this.connect = connect;
    this.clientTokens = {};
    this.tokens = {};
    this.expire_start = null;
    this.expire_end = null;
    this.expire_client_start = null;
    this.expire_client_end = null;
  }
  requestTokensByRefresh(refreshToken) {
    /*  
      (refreshToken:string):Promise|void
      */
    if(!refreshToken){
      let tokens=this.getTokens();
      if(typeof tokens==='object'){
        refreshToken = tokens.refresh_token;
      }
    }
    let { connect } = this;
    if (!connect || !refreshToken) {
      return;
    }
    let { appKey, appSecret } = connect;

    return new Promise((resolve, reject) => {
      refreshTokenFunc(appKey, appSecret, refreshToken)
        .then(tokens => {
          let out = this.setTokens(tokens);
          connect.trigger('tokens', out);
          resolve(out);
        })
        .catch(err => {
          connect.trigger('error', error.token(err));
          reject(err);
        });
    });
  }
  requestTokens(code) {
    let { connect } = this;
    if (!connect || !code) {
      return;
    }
    let { appKey, appSecret, redirect_uri } = connect;
    return new Promise((resolve, reject) => {
      oauth2(appKey, appSecret, redirect_uri, code)
        .then(tokens => {
          let out = this.setTokens(tokens);
          connect.trigger('tokens', out);
          resolve(out);
        })
        .catch(err => {
          connect.trigger('error', error.token(err));
          reject(err);
        });
    });
  }
  requestClientTokens() {
    let { connect } = this;
    if (!connect) {
      return;
    } //unbind connect
    let { appKey, appSecret } = connect;
    return new Promise((resolve, reject) => {
      clientTokenFunc(appKey, appSecret)
        .then(tokens => {
          let out = (this.clientTokens = Object.assign(
            this.clientTokens,
            tokens
          ));
          connect.trigger('clientTokens', out);
          resolve(out);
        })
        .catch(err => {
          connect.trigger('error', error.clientToken(err));
          reject(err);
        });
    });
  }
  expiredClient() {
    let date = new Date();
    if (this.expire_client_end) {
      return isAfter(date, this.expire_client_end);
    } else {
      return false; //if not expire_end, also return false
    }
  }
  expired() {
    let date = new Date();
    if (this.expire_end) {
      return isAfter(date, this.expire_end);
    } else {
      return false; //if not expire_end, also return false
    }
  }
  setClientTokens(clientTokens) {
    // this.clientTokens = Object.assign(this.clientTokens, tokens);
    this.clientTokens = Object.assign(this.clientTokens, clientTokens);
    let { expires_in } = clientTokens;
    if (expires_in) {
      let da = (this.expire_client_start = new Date());
      this.expire_client_end = addSeconds(da, Math.floor(expires_in / 2));
    }
    return clientTokens;
  }
  setTokens(tokens) {
    /* 
    Interface Tokens{
      access_token?:string;
      refresh_token?:string;
      expi
    }
    */
    this.tokens = Object.assign(this.tokens, tokens);
    let { expires_in } = tokens;
    if (expires_in) {
      let da = (this.expire_start = new Date());
      this.expire_end = addSeconds(da, expires_in);
    }
    return tokens;
  }
  getClientTokens() {
    //not to others
    let clientTokens = this.clientTokens;
    if (clientTokens.access_token) {
      return clientTokens;
    } else {
      return false;
    }
  }
  getTokens() {
    //not to others
    let tokens = this.tokens;
    if (tokens.access_token) {
      return tokens;
    }
    return false;
  }
  clear() {
    this.connect = null;
  }
}

class Oauth2 extends utils.Event {
  constructor(appKey, appSecret, redirect_uri) {
    super();
    this.appKey = appKey;
    this.appSecret = appSecret;
    this.redirect_uri = redirect_uri;
    this.store = {};
  }
  on(eventType, callback) {
    if (!eventType || typeof callback !== 'function') {
      return;
    }
    if (Oauth2.supportEvents.indexOf(eventType) !== -1) {
      //is supported event;
      super.on(eventType, callback);
    } else {
      utils.debug()(`${eventType} is not supported event`);
    }
  }
  connectByRefresh(refreshToken) {
    /* 
        (refreshToken:string):Promise
    */
    return new Promise((resolve, reject) => {
      let newConnection = new UserToken(this);

      newConnection
        .requestTokensByRefresh(refreshToken)
        .then(() => {
          resolve(newConnection);
        })
        .catch(err => {
          reject(err);
        });
    });
  }
  connectByCode(code) {
    return new Promise((resolve, reject) => {
      let newConnection = new UserToken(this);
      newConnection
        .requestTokens(code)
        .then(() => {
          resolve(newConnection);
        })
        .catch(err => {
          reject(err);
        });
    });
  }
  connectByTokens(tokens) {
    let newConnection = new UserToken(this);
    newConnection.setTokens(tokens);
    return newConnection;
  }
  connect() {
    /* 
    ():UserToken
    */
    return new UserToken(this);
  }
}

Oauth2.supportEvents = ['tokens', 'clientTokens', 'error'];

export default Oauth2;
