import utils from 'Utils';
import transform from 'Services/transform';
import channelList from 'Plugins/channelList';
import sendMessage from 'Plugins/sendMessage';
import getUser from 'Plugins/getUser';
import error from 'Services/error';


class ClientApp {
  constructor(robot_jid, auth) {
    this.robot_jid = robot_jid;
    this.auth = auth;
  }
  getToken(func, fail) {
    let { auth } = this;
    let expired = auth.expired();
    let tokens = auth.getTokens();
    if (tokens === false) {
      let msg = `don't get tokens before use action`;
      error.code({ type: 'code', message: msg });
      fail(msg);
      return;
    }
    let { refresh_token, access_token } = tokens;
    if (expired === true) {
      auth
        .requestTokensByRefresh(refresh_token)
        .then(newTokens => {
          func(newTokens.access_token);
        })
        .catch(err => {
          fail(err);
        });
    } else {
      func(access_token);
    }
  }
  getClientToken(func, fail) {
    let { auth } = this;
    let expired = auth.expiredClient();
    let clientTokens = auth.getClientTokens();
    if (clientTokens === false) {
      auth
        .requestClientTokens()
        .then(newClientTokens => {
          func(newClientTokens.access_token);
        })
        .catch(err => {
          fail(err);
        });
      return;
    }
    let { access_token } = clientTokens;
    if (expired === true) {
      auth
        .requestClientTokens()
        .then(newClientTokens => {
          func(newClientTokens.access_token);
        })
        .catch(err => {
          fail(err);
        });
    } else {
      func(access_token);
    }
  }
  getUser(email) {
    return new Promise((resolve, reject) => {
      this.getToken(
        access_token => {
          getUser(access_token, email)
            .then(data => {
              resolve(data);
            })
            .catch(err => {
              reject(err);
            });
        },
        err => {
          error.action({ type: 'action', message: err });
          reject(err);
        }
      );
    });
  }
  sendMessage(option) {
    return new Promise((resolve, reject) => {
      this.getClientToken(
        access_token => {
          let { robot_jid } = this;
          let { body, header, account_id, to_jid } = option;
          sendMessage(access_token, to_jid, robot_jid, account_id, body, header)
            .then(data => {
              resolve(data);
            })
            .catch(err => {
              reject(err);
            });
        },
        err => {
          error.action({ type: 'action', message: err });
          reject(err);
        }
      );
    });
    // return sendMessage(userId,to_jid,body,header)
  }
  channelList(userId) {
    return new Promise((resolve, reject) => {
      this.getToken(
        access_token => {
          channelList(access_token, userId)
            .then(data => {
              resolve(data);
            })
            .catch(err => {
              reject(err);
            });
        },
        err => {
          error.action({ type: 'action', message: err });
          reject(err);
        }
      );
    });
  }
  clear() {
    this.auth = null;
  }
}





class Client extends utils.Event {
  constructor(appKey, verification_token, robot_jid, name = '') {
    super();
    this.appKey = appKey;
    this.robot_jid = robot_jid;
    this.verification_token = verification_token;
    this.commandStore = [];
    this.focusApp = null;
    this.name = name;
    this.v = '';
  }
  defaultAuth(connection){
    if(connection){
      let { robot_jid } = this;
      this.focusApp = new ClientApp(robot_jid, connection);
    }
    return this;
  }
  create(opt) {
    //opt reserve
    // if (typeof opt !== 'object') {
    //   utils.debug()(
    //     `create client must input object which include auth or tokens,clientTokens`
    //   );
    //   return;
    // }
    let { auth } = opt;
    let { robot_jid } = this;
    let newApp = new ClientApp(robot_jid, auth);
    if(this.focusApp===null){
      this.focusApp = newApp;
    }
    return newApp;
  }
  command(opts) {//abandon method
    if (Array.isArray(opts)) {
      opts.forEach((obj) => {
        this._commandObj(obj);
      });
    }
    else if (typeof opts === 'object') {
      this._commandObj(opts);
    }
    return this;
  }
  _commandObj(obj) {//aband
    if (typeof obj === 'object') {
      //['command','description'] hint?
      if (utils.hasAllAttrs(obj, ['command', 'description'])) {
        this.commandStore.push(obj);
      }
    }
  }
  _commandsObj(obj) {
    if (typeof obj === 'object') {
      //['command','description'] hint?
      if (utils.hasAllAttrs(obj, ['command', 'description'])) {
        this.commandStore.push(obj);
      }
    }
  }
  commands(opts){
    if (Array.isArray(opts)) {
      opts.forEach((obj) => {
        this._commandsObj(obj);
      });
    }
    else if (typeof opts === 'object') {
      this._commandsObj(opts);
    }
    return this;
  }
  version(v) {
    this.v = v;
    return this;
  }
  route({ body, headers }) {
    let { appKey, verification_token } = this;
    let out = transform.get({
      body,
      headers,
      store: this.store,
      appKey,
      verification_token
    });
    return out;
  }
  async triggerHelp(data, allCallback) {
    let { accountId: account_id, toJid: to_jid } = data;
    let {  focusApp, commandStore, name } = this;
    let msg = [];
    if (commandStore.length === 0) {
      msg.push({
        type: 'message',
        text: 'No Command Now'
      });
    }
    else {
      commandStore.forEach((obj) => {
        let { command, description, hint } = obj;
        let commandTitle=command;
        if(hint){commandTitle=`${commandTitle} ${hint}`;}
        let commandInfo = [{
          type: 'message',
          text: commandTitle,
          style: {
            bold: true
          }
        }];
        let valueInfo = [{
          type: 'message',
          text: description
        }];
        msg = msg.concat(commandInfo);
        msg = msg.concat(valueInfo);
      });
    }
    let title = `Hi this is bot commands`;
    if (name) {
      title = `Hi this is ${name} bot commands`;
    }

    try {//this position
      await focusApp.sendMessage({
        to_jid,
        account_id,
        body: msg,
        header: { text: title }
      });
    }
    catch (e) {
      if (typeof allCallback === 'function') {
        allCallback(e);
      }
    }
  }
  handleCallback(result, allCallback) {//run the help split,and normal command split,and parse one to one and group,and commandName
    let { type, innerCmd, value, data, cmdOption={},message} = result;
    let { focusApp } = this;
    if (value === 'notification' && innerCmd === 'help' && focusApp !== null) {
      this.triggerHelp(data, allCallback);
    }
    else {
      this.trigger(value, { data, type, command: value });//old trigger
      this.trigger('command', { data, type, command: value });//old trigger
      //change data->commands
      this.trigger('commands', { payload: data, data: cmdOption.hint, type, message, command:cmdOption.command });
    }
  }
  handle({ body, headers }, allCallback) {
    if (typeof body !== 'object') {
      //only check body
      if (typeof allCallback === 'function') {
        allCallback(`no body and query data`);
      }
      return this;
    }
    let routeEntity = this.route({ body, headers });
    if (routeEntity.status === false) {
      if (routeEntity.errorMessage && typeof allCallback === 'function') {
        allCallback(routeEntity.errorMessage);
      }
      return this;
    }
    //value is which route to route

    //split help and command
    this.handleCallback(routeEntity.result, allCallback);
    // this.trigger(value, {data});
    // .then(() => {
    //   if (typeof allCallback === 'function') {
    //     allCallback(null);
    //   }
    // })
    // .catch(err => {
    //   if (typeof allCallback === 'function') {
    //     allCallback(err);
    //   }
    // });
    return this;
  }
}

export default Client;
