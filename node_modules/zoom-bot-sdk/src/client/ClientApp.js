import channelList from '../plugins/channelList';
import sendMessage from '../plugins/sendMessage';
import getUser from '../plugins/getUser';
import request from '../plugins/request';
import error from '../services/error';


class ClientApp {
    constructor(robot_jid, auth) {
        this.robot_jid = robot_jid;
        this.auth = auth;
    }
    getToken(func, fail) {
        let { auth } = this;
        let expired = auth.expired();
        let tokens = auth.getTokens();
        if (tokens === false) {
            let msg = `don't get tokens before use action`;
            error.code({ type: 'code', message: msg });
            fail(msg);
            return;
        }
        let { refresh_token, access_token } = tokens;
        if (expired === true) {
            auth
                .requestTokensByRefresh(refresh_token)
                .then(newTokens => {
                    func(newTokens.access_token);
                })
                .catch(err => {
                    fail(err);
                });
        } else {
            func(access_token);
        }
    }
    getClientToken(func, fail) {
        let { auth } = this;
        let expired = auth.expiredClient();
        let clientTokens = auth.getClientTokens();
        if (clientTokens === false) {
            auth
                .requestClientTokens()
                .then(newClientTokens => {
                    func(newClientTokens.access_token);
                })
                .catch(err => {
                    fail(err);
                });
            return;
        }
        let { access_token } = clientTokens;
        if (expired === true) {
            auth
                .requestClientTokens()
                .then(newClientTokens => {
                    func(newClientTokens.access_token);
                })
                .catch(err => {
                    fail(err);
                });
        } else {
            func(access_token);
        }
    }
    request(opt,type='access') {
        
        if(typeof opt!=='object'){
            throw new error.ParamError(`${opt} must be object`);
            // return;
        }
        return new Promise((resolve, reject) => {
            if (type === 'access') {
                type = 'getToken';
            }
            else if (type === 'credential') {
                type = 'getClientToken';
            }
            else {
                reject(`param type must be access or credential`);
                return;
            }
            this[type](
              access_token => {
                request(access_token, opt)
                  .then(data => {
                    resolve(data);
                  })
                  .catch(err => {
                    reject(err);
                  });
              },
              err => {
                error.action({ type: 'action', message: err });
                reject(err);
              }
            );
        });
    }
    getUser(email) {
        return new Promise((resolve, reject) => {
            this.getToken(
                access_token => {
                    getUser(access_token, email)
                        .then(data => {
                            resolve(data);
                        })
                        .catch(err => {
                            reject(err);
                        });
                },
                err => {
                    error.action({ type: 'action', message: err });
                    reject(err);
                }
            );
        });
    }
    sendMessage(option) {
        return new Promise((resolve, reject) => {
            this.getClientToken(
                access_token => {
                    let { robot_jid } = this;
                    let { body, header, account_id, to_jid } = option;
                    sendMessage(access_token, to_jid, robot_jid, account_id, body, header)
                        .then(data => {
                            resolve(data);
                        })
                        .catch(err => {
                            reject(err);
                        });
                },
                err => {
                    error.action({ type: 'action', message: err });
                    reject(err);
                }
            );
        });
        // return sendMessage(userId,to_jid,body,header)
    }
    channelList(userId) {
        return new Promise((resolve, reject) => {
            this.getToken(
                access_token => {
                    channelList(access_token, userId)
                        .then(data => {
                            resolve(data);
                        })
                        .catch(err => {
                            reject(err);
                        });
                },
                err => {
                    error.action({ type: 'action', message: err });
                    reject(err);
                }
            );
        });
    }
    clear() {
        this.auth = null;
    }
}

export default ClientApp;